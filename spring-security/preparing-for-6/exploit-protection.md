以下の手順は、CSRFの設定方法に関する変更に関連するものです。

# Defer Loading CsrfToken

Spring Security 5では、デフォルトの動作として、CsrfTokenはリクエストごとに読み込まれます。つまり、典型的なセットアップでは、不要な場合でもリクエストごとにHttpSessionを読み込む必要があります。

[NOTE]
セッションを読む必要がない例としては、静的資産、静的HTMLページ、同じドメイン/サーバーでホストされている単一ページのアプリケーションなど、permitAll()とマークされているエンドポイントがあります。

Spring Security 6では、CsrfTokenのルックアップは必要になるまで延期されるのがデフォルトです。

[NOTE]
CsrfTokenは、アプリケーションの状態を変更するようなHTTP動詞でリクエストが行われるたびに必要となります。これについては、[「安全なメソッドは冪等でなければならない」](https://docs.spring.io/spring-security/reference/5.8/features/exploits/csrf.html#csrf-protection-idempotent)
で詳しく説明しています。さらに、CSRFトークンのための隠し<input>を含む<form>タグを持つWebページのように、トークンをレスポンスにレンダリングするすべてのリクエストで必要とされます。

新しいSpring Security 6のデフォルトにオプトインするためには、次のような構成が考えられます。

```java
@Bean
public SecurityFilterChain springSecurity(HttpSecurity http)throws Exception{
        CsrfTokenRequestAttributeHandler requestHandler=new CsrfTokenRequestAttributeHandler();
        // set the name of the attribute the CsrfToken will be populated on
        requestHandler.setCsrfRequestAttributeName("_csrf");
        http
        // ...
        .csrf((csrf)->csrf
        .csrfTokenRequestHandler(requestHandler)
        );
        return http.build();
        }
```

[NOTE]
CsrfTokenがdeferred（Spring Security 6のデフォルト）の場合、
deferredでないCSRFトークンで設計されたことが原因で、一部のアプリケーションが壊れることがあります。詳しくは下記の[Opt-out Steps](https://docs.spring.io/spring-security/reference/5.8/migration/servlet/exploits.html#servlet-defer-loading-csrf-token-opt-out)
を参照してください。

## Opt-out Steps

CsrfTokenを遅延させる設定に問題がある場合は、最適なオプトアウト動作のためのシナリオを参照してください：

### I am using a Single-Page Application with CookieCsrfTokenRepository

シングルページアプリ（SPA）を使って、CookieCsrfTokenRepository.withHttpOnlyFalse()とともにSpring
Securityで保護されたバックエンドに接続している場合、サーバーへの最初のリクエストでCSRFトークンがクッキーとしてアプリケーションに戻らなくなったことがわかるかもしれません。

この場合、クライアント側のアプリケーションが期待する動作を復元するためのいくつかのオプションがあります。そのひとつは、どのリクエストが最初に作られたかに関係なく、CsrfTokenをレスポンスに熱心にレンダリングするフィルタを、次のように追加することです：

```java
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http)throws Exception{
        CookieCsrfTokenRepository tokenRepository=CookieCsrfTokenRepository.withHttpOnlyFalse();
        CsrfTokenRequestAttributeHandler requestHandler=new CsrfTokenRequestAttributeHandler();
        // set the name of the attribute the CsrfToken will be populated on
        requestHandler.setCsrfRequestAttributeName("_csrf");
        http
        // ...
        .csrf((csrf)->csrf
        .csrfTokenRepository(tokenRepository)
        .csrfTokenRequestHandler(requestHandler)
        )
        .addFilterAfter(new CsrfCookieFilter(),BasicAuthenticationFilter.class);

        return http.build();
        }

private static final class CsrfCookieFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        CsrfToken csrfToken = (CsrfToken) request.getAttribute(CsrfToken.class.getName());
        // Render the token value to a cookie by causing the deferred token to be loaded
        csrfToken.getToken();

        filterChain.doFilter(request, response);
    }

}
```

上記のオプションは、シングル・ページ・アプリケーションを変更する必要はありませんが、リクエストごとにCsrfTokenがロードされるようになります。リクエストごとにトークンを熱心にロードするフィルタを追加したくない場合は、以下に追加のオプションを示します。

### I am using a Single-Page Application with HttpSessionCsrfTokenRepository

セッションを使用している場合、アプリケーションは deferred tokens の恩恵を受けることができます。オプトアウトする代わりに、次のように /csrf エンドポイントを持つ新しい
@RestController を追加するのもひとつの方法です：

```java

@RestController
public class CsrfController {

    @GetMapping("/csrf")
    public CsrfToken csrf(CsrfToken csrfToken) {
        return csrfToken;
    }

}
```

[NOTE] 上記のエンドポイントがサーバーとの認証前に必要な場合は、.requestMatchers("/csrf").permitAll()を追加することを検討することができます。

csrfエンドポイントは、後続のリクエストのためにアプリケーションをブートストラップするために、クライアント側のアプリケーションによって消費される必要があります。

[NOTE] アプリケーション起動時に/csrfエンドポイントを呼び出す方法は、クライアントサイドフレームワークに固有のため、本書の範囲外です。

[NOTE] この場合、単一ページのアプリケーションに変更を加える必要がありますが、CSRF
トークンを読み込むのは一度だけで、トークンは引き続き遅延させることができるという利点があります。この方法は、HttpSessionCsrfTokenRepositoryを使用し、リクエストごとにHttpSessionを読み込まないようにすることでトークンの遅延の恩恵を受けるアプリケーションで特にうまく機能します。

もし、単に延期されたトークンを完全にオプトアウトしたいのであれば、そのオプションを次に示します。

### I need to opt out of deferred tokens for another reason

もし、deferred tokensが他の理由であなたのアプリケーションを壊してしまうのであれば、以下の設定を使って明示的に5.8のデフォルトを選択することが可能です：

```java
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http)throws Exception{
        CsrfTokenRequestAttributeHandler requestHandler=new CsrfTokenRequestAttributeHandler();
        // set the name of the attribute the CsrfToken will be populated on
        requestHandler.setCsrfRequestAttributeName(null);
        http
        // ...
        .csrf((csrf)->csrf
        .csrfTokenRequestHandler(requestHandler)
        );
        return http.build();
        }
```

[NOTE] csrfRequestAttributeNameをnullに設定すると、使用する属性名を決定するためにCsrfTokenを最初にロードする必要があります。これにより、CsrfTokenはすべてのリクエストでロードされます。

# Protect against CSRF BREACH

[Defer Loading CsrfToken](https://docs.spring.io/spring-security/reference/5.8/migration/servlet/exploits.html#_defer_loading_csrftoken)
の手順がうまくいった場合、以下の設定を使用して、Spring Security 6のデフォルトサポートであるCsrfTokenのBREACHプロテクションを選択することも可能です：

```java
@Bean
DefaultSecurityFilterChain springSecurity(HttpSecurity http)throws Exception{
        XorCsrfTokenRequestAttributeHandler requestHandler=new XorCsrfTokenRequestAttributeHandler();
        // set the name of the attribute the CsrfToken will be populated on
        requestHandler.setCsrfRequestAttributeName("_csrf");
        http
        // ...
        .csrf((csrf)->csrf
        .csrfTokenRequestHandler(requestHandler)
        );
        return http.build();
        }
```

## Opt-out Steps

CSRF BREACH対策の設定に悩んだら、最適なオプトアウト動作のためのシナリオを参考にしてください：

### I am using AngularJS or another Javascript framework

AngularJSと[HttpClientXsrfModule](https://angular.io/api/common/http/HttpClientXsrfModule)
（または他のフレームワークの類似モジュール）をCookieCsrfTokenRepository.withHttpOnlyFalse()とともに使用している場合、自動サポートが機能しなくなることがある。

この場合、Spring SecurityがCookieから生のCsrfTokenを検証しつつ、レスポンスのCSRF
BREACH保護を維持するように、デリゲーション付きのカスタムCsrfTokenRequestHandlerを使って、以下のように設定することができます：

```java
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http)throws Exception{
        CookieCsrfTokenRepository tokenRepository=CookieCsrfTokenRepository.withHttpOnlyFalse();
        XorCsrfTokenRequestAttributeHandler delegate=new XorCsrfTokenRequestAttributeHandler();
        // set the name of the attribute the CsrfToken will be populated on
        delegate.setCsrfRequestAttributeName("_csrf");
        // Use only the handle() method of XorCsrfTokenRequestAttributeHandler and the
        // default implementation of resolveCsrfTokenValue() from CsrfTokenRequestHandler
        CsrfTokenRequestHandler requestHandler=delegate::handle;
        http
        // ...
        .csrf((csrf)->csrf
        .csrfTokenRepository(tokenRepository)
        .csrfTokenRequestHandler(requestHandler)
        );

        return http.build();
        }
```

これは、Cookie値を使用するクライアントサイドのアプリケーションと連携するためにSpring
Securityを設定するRECOMMENDEDな方法で、アプリケーションが知らないうちにBREACHの脆弱性があるHTMLなどのレスポンスを返す場合に備えて、CSRFトークンの値をランダムに返すことを許可し続けているからです。

[NOTE] BREACHプロテクションは、トークンがGZIP圧縮可能なレスポンスボディに含まれる場合に保護する仕組みで、一般的にヘッダーやクッキーは含まれない。

[TIP]
サーバーから返されたトークン値は、基本的な（生の）CSRFトークンが変化しないため、クライアント側のアプリケーションで正常に使用することができます。AngularJS（または類似の）アプリケーションでは、リクエストの前後でCSRFトークンをリフレッシュする必要はありません。

CSRF BREACHの保護機能を完全に停止したい場合は、次のオプションをご利用ください。

### I need to opt out of CSRF BREACH protection for another reason

CSRF BREACH保護が別の理由で機能しない場合は、
[「Defer Loading CsrfToken」](https://docs.spring.io/spring-security/reference/5.8/migration/servlet/exploits.html#servlet-opt-in-defer-loading-csrf-token)
セクションの設定を使用してオプトアウトすることができます。

# CSRF BREACH with WebSocket support

[「CSRFのBREACHから保護する」](https://docs.spring.io/spring-security/reference/5.8/migration/servlet/exploits.html#_protect_against_csrf_breach)
の手順が
通常のHTTPリクエストで機能し、[WebSocket Security](https://docs.spring.io/spring-security/reference/5.8/servlet/integrations/websocket.html)
サポートを使用している場合、[Stompヘッダー](https://docs.spring.io/spring-security/reference/5.8/servlet/integrations/websocket.html#websocket-sameorigin-csrf)
によるCsrfTokenのBREACH保護のためのSpring Security 6のデフォルトサポートを選択することも可能です。
```java
@Bean
ChannelInterceptor csrfChannelInterceptor() {
	return new XorCsrfChannelInterceptor();
}
```
WebSocket SecurityのCSRF BREACH保護の設定が面倒な場合は、以下の設定で5.8のデフォルトを設定することが可能です：
```java
@Bean
ChannelInterceptor csrfChannelInterceptor() {
	return new CsrfChannelInterceptor();
}
```
